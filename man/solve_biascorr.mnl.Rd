% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/solve_biascorr.R
\name{solve_biascorr.mnl}
\alias{solve_biascorr.mnl}
\title{Bias correction solver for multinomial logit type problems}
\usage{
solve_biascorr.mnl(
  targets,
  areas,
  xmat,
  betas,
  priors = NULL,
  restrictions = NULL,
  options = get_opts.solve_biascorr()
)
}
\arguments{
\item{targets}{A p x 1  vector of downscaling targets (with at least one targets >= 0)}

\item{areas}{An n x 1  vector of grid areas, with all areas >= 0 and with sum(areas) >= sum(targets)}

\item{xmat}{An n x k  matrix of explanatory variables}

\item{betas}{A k x p1 matrix (with p = p1 + p2)}

\item{priors}{A n x p2 matrix of priors (with priors >= 0)}

\item{restrictions}{A n x p binary matrix of restrictions; if restrictions are one, the MNL function is set to zero}

\item{options}{A list with solver options. Call \code{\link{get_opts.solve_biascorr}} for default options and for more detail.}
}
\value{
A list containing
\itemize{
\item \code{out.res} A n x p matrix of area allocations
\item \code{out.solver} A list of the solver output
}
}
\description{
Bias correction solver for multinomial logit type problems
}
\details{
Given p targets matches either the projections from an MNL-type model or exogeneous priors.

min \deqn{\sum  (  z ij areas_i  - targets_j )^2}
s.t. \deqn{ z_ij = \mu_ij}
\deqn{\mu_ij = \lambda_ij / (1 + \sum \lambda_ij )}
\deqn{\lambda_ij = x_j + \exp xmat_i betas_j} or \eqn{\lambda_ij = x_j + priors_ij}
\deqn{x_j >= 0}
with \eqn{i = 1,...,n} and  \eqn{j = 1,...,n}. #' For each target either betas and xmats or priors have to be supplied. Priors have to be strictly larger or equal to zero.

When \code{cutoff} is specified, \eqn{z_ij} is defined as above if \eqn{mu_ij > cutoff}. If \eqn{mu_ij <= cutoff} then \eqn{z_ij = 0}. Per default \code{cutoff} is set to zero.

Restrictions are binary and optional. If restrictions are supplied, in case \eqn{restrictions_ij = 1} then  \eqn{z_ij = 0}.
}
\examples{
## A basic example
lu.to = c("crop","grass","forest","other")
n <- 100; k = 3
areas = 5+runif(n)
targets = runif(length(lu.to),1,sum(areas) / length(lu.to))
names(targets) = lu.to
betas = array(sample(-2:2,k*length(lu.to),replace = TRUE),c(k,length(lu.to)))
row.names(betas) = 1:k; colnames(betas) = lu.to
xmat = matrix(rnorm(n*k),n,k)
row.names(xmat) = 1:n; colnames(xmat) = 1:k
res1 = solve_biascorr.mnl(targets = targets,areas = areas,xmat = xmat,betas = betas)

## An example using priors
betas2 = betas[,-1]
priors = matrix(runif(n),n,1); colnames(priors) = lu.to[1]
res2 = solve_biascorr.mnl(targets = targets,areas = areas,xmat = xmat,
                         betas = betas2,priors = priors)

## An example with restrictions
restrictions = matrix(0,n,length(lu.to));
row.names(restrictions) = 1:n; colnames(restrictions) = lu.to
restrictions[,2] = sample(c(0,1),replace = TRUE,size = n)
res3 = solve_biascorr.mnl(targets = targets,areas = areas,xmat = xmat,
                         betas = betas2,priors = priors,
                         restrictions = restrictions)
}
